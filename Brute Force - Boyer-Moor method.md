# Brute Force - Boyer-Moor method

## [참고] Brute Force 란 ?

> brute : 무식한, force: 힘 무식한 힘 ? 
>
> Brute Force는 완전탐색 알고리즘으로 가능한 모든 경우의 수를 모두 탐색하면서 요구조건에 충족되는 결과만을 가져오는 알고리즘이다.
>
> 이 알고리즘의 강력한 점은 예외 없이 100% 확률로 요구조건에 충족하는 값을 얻을 수 있다는 점이다. 

- 일반적 방법으로 문제를 해결하기 위해서는 모든 자료를 탐색해야 하기 때문에 특정한 구조를 전체적으로 탐색할 수 있는 방법을 필요로 한다.
- 알고리즘 설계의 가장 기본적인 접근 방법은 **"해가 존재할 것으로 예상되는 모든 영역을 전체 탐색 하는 방법"**
- 선형 구조를 전체적으로 탐색하는 순차 탐색, 비선형 구조를 전체적으로 탐색하는 **깊이 우선 탐색(DFS, Depth First Search)**과 **너비 우선 탐색(BFS, Breadth First Search)**이 가장 기본적인 도구이다. 

## 1. 문자열 검색이란?

> 문자열 검색은 어떤 문자열 안에 다른 문자열이 포함되어 있는지 검사하고, 만약 포함되어 있다면 어디에 위치하는 지 찾아내는 것을 말한다.

- 예를 들어 'STRING'이라는 문자열에서 'IN'을 검색하면 성공하지만, QUE를 검색하면 실패한다. 
- 여기서 'STRING'을 텍스트, 'IN'을 패턴이라고 한다.
- 정리하자면 문자열 A를 텍스트, 문자열 B를 패턴이라고 가정하면, 문자열 검색은 문자열 A에서 문자열 B를 찾아내는 알고리즘을 말한다.



## 2. Boyer-Moor method

> 보이어 무어법은 KMP법보다 더 효율적이어서 실제 문자열 검색에서 널리 널리 사용되는 알고리즘이다. BF 방법 (O(mn))보다 성능이 좋다.

- 패턴의 끝 문자에서 시작하여 앞쪽을 향해 검사를 수행한다. 이 과정에서 일치하지 않는 문자를 발견하면 미리 준비한 표를 바탕으로 패턴이 이동하는 값을 결정한다.
- 예를들어 보이어 무어법으로 텍스트 'ABCDXDEZCABACABAC'에서 패턴'ABAC'를 검색하는 과정을 살펴보자

```python
A B C X D E Z C A B A C A B A C
  	  A B A C                      #텍스트와 패턴의 문자가 일치하지 않는다.
   		A B A C					   #패턴을 오른쪽으로 1칸 밀어도 일치하지 않는다.
     	  A B A C				   #패턴을 오른쪽으로 2칸 밀어도 일치하지 않는다.
	   		A B A C				   #패턴을 오른쪽으로 3칸 밀어도 일치하지 않는다.
```





```python
A B C X D E Z C A B A C A B A C
		A B A C      	# 패턴의 마지막 부분인 C를 텍스트와 비교,일치, 1칸 밀어 A 비교
    	  A B A C    	# 일치하지 않아서 1칸 민다.
            A B A C  	# 또 일치하지 않아서 1칸 민다.
              A B A C 	# 일치하지 않는다 !
```

- 이처럼 패턴에 포함되지 않는 문자를 텍스트에서 발견하면, 그 위치까지는 건너 뛸 수 있다.



```python
A B C X D E Z C A B A C A B A C
			  A B A C			#(1)일치하지 않는다.
    			A B A C			#(2)패턴을 오른쪽으로 1칸 밀면 A가 일치
        		  A B A C		#(3)패턴을 오른쪽으로 2칸 밀어도 일치 하지 않는다.
            		A B A C		#(4)패턴을 오른쪽으로 3칸 밀면 안된다.
```

- (1)에서, 패턴의 마지막 문자 C는 텍스트 문자 A와 일치하지 않는다. 그런데 문자 A는 패턴의 1번째와 3번째에 포함되어 있다. 그래서 (2)처럼 뒤쪽에 있는 A가 위 아래로 겹치도록 패턴을 오른쪽으로 1칸만 밀어낸다.

```python
A B C X D E Z C A B A C A B A C
				A B A C 
    			<------
```

- 이후 (2)상태에서 맨 끝부터 문자를 차례로 비교하면 모든 문자가 일치하므로 검색에 성공한다.



## 3. 건너뛰기 표

>  보이어 무어법 알고리즘은 각각의 문자를 만났을 때 패턴을 이동할 크기를 저장하는 표(건너뛰기 표) 를 미리 만들어 둘 필요가 있다. 패턴 문자열의 길이가 n일 때 이동할 크기(이동량)는 다음과 같이 결정한다.

- 패턴에 포함되지 않는 문자를 만난 경우
  - 패턴 이동량이 곧 n이다. 앞에서 살펴본  첫번째 python창에 해당한다. X는 패턴에 포함되지 않으므로 4문자만큼 밀어낸다.

- 패턴에 포함되는 문자를 만난 경우
  - 마지막에 나오는 위치의 인덱스가 k이면 이동량은 n - k - 1이다. 앞에서 살펴본 세번째 python창에 해당한다. A는 패턴 안의 두 곳에 있다. 패턴을 오른쪽으로 1칸 밀어낸다.
  - 같은 문자가 패턴안에 중복해서 존재하지 않으면 패턴의 맨 끝 문자의 이동량은 n이다. 예를 들어 ABAC의 C를 만나면 이동할 필요가 없으므로 이동량은 n이다.

| A    | B    | C    | D    | E    | F    | G    | H    | I    | J    | K    | L    | M    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    |

| N    | O    | P    | Q    | R    | S    | T    | U    | V    | W    | X    | Y    | Z    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    |

# 4. 구현

패턴이 "ABAC"4개의 문자이므로, 패턴 안에 존재할 수 있는 모든 문자의 이동량을 계산하면 4**4 = 256이 된다. 이 건너뛰기 표에서 사용하는 원소는 256개이다.

```python

```



## Reference

